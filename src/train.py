# -*- coding: utf-8 -*-
"""train.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NWpRjyZLzEaOyJas_87TdqzQDrkg1sAy
"""

import time
import os
import tqdm

import torch
import torch.optim as optim
import torch.nn as nn

!cp /content/drive/MyDrive/Colab\ Notebooks/SRCNN_Implementation/model.py .
!cp /content/drive/MyDrive/Colab\ Notebooks/SRCNN_Implementation/dataset.py .
!cp /content/drive/MyDrive/Colab\ Notebooks/SRCNN_Implementation/utils.py .
from model import SRCNN
from datasets import load_datasets
from utils import PSNR

# SOURCES:
# - https://pytorch.org/docs/stable/generated/torch.optim.SGD.html
# - https://pytorch.org/docs/stable/generated/torch.nn.MSELoss.html#torch.nn.MSELoss
# - https://pytorch.org/docs/stable/generated/torch.nn.Module.html
# - https://pytorch.org/docs/stable/generated/torch.optim.Optimizer.zero_grad.html
# - https://pytorch.org/docs/stable/generated/torch.no_grad.html

# Training parameters
device = 'cuda' if torch.cuda.is_available() else 'cpu'

# Initialize the model
print('Device: ', device)
model = SRCNN().to(device)

# Initialize the optimizer (SGD)
optimizer = optim.SGD(
    [{"params": model.patch_extraction.parameters()},
     {"params": model.nonLinear_map.parameters()},
     {"params": model.reconstruction.parameters(), "lr": 1e-5}], # Set to 1e-5 for the last layer
    lr=1e-4,
    momentum=0.9,
    model_weight_decay=1e-4
)
# Initialize the loss function (used to update weights during training)
loss_function = nn.MSELoss()

# Load the training and validation data
lr_train_path = '/content/drive/MyDrive/Colab Notebooks/SRCNN_Implementation/data/T91/lr_sub_image'
hr_train_path = '/content/drive/MyDrive/Colab Notebooks/SRCNN_Implementation/data/T91/hr_sub_image '
lr_val_path = '/content/drive/MyDrive/Colab Notebooks/SRCNN_Implementation/data/Set5/lr_image'
hr_val_path = '/content/drive/MyDrive/Colab Notebooks/SRCNN_Implementation/data/Set5/Original'

train_loader, val_loader = load_datasets(lr_train_path, hr_train_path, lr_val_path, hr_val_path)

def train(model, train_loader):
  """
  Function to train the CNN model with training data
  """
  # Set model to training mode
  model.train()

  # Set initial training loss and psnr to 0.0
  running_loss = 0.0
  running_psnr = 0.0

  # Loop through training dataset batch by batch
  for batch_idx, data in tqdm(enumerate(train_loader), total=len(train_loader)):
    # Move the LR and HR training images to device (GPU or CPU)
    lr_image = data[0].to(device)
    hr_image = data[1].to(device)

    # Clear gradients stored previously, to prevent wrong weight updates
    optimizer.zero_grad()

    # Input LR image into model
    outputs = model(lr_image)
    # Calculate loss for current batch
    loss = loss_function(outputs, hr_image)
    # Backpropagation
    loss.backward()
    # Update the weights
    optimizer.step()

    # Add the total loss (to get total loss for current epoch)
    running_loss += loss.item()

    # Calculate PSNR for current batch
    batch_psnr = PSNR(hr_image, outputs)
    # Add the total PSNR (to get total PSNR for current epoch)
    running_psnr += batch_psnr

  # Calcualte the average loss and PSNR for current epoch
  avg_loss = running_loss/len(train_loader.dataset)
  avg_psnr = running_psnr/len(train_loader)

  return avg_loss, avg_psnr

def validate(model, val_loader):
  """
  Function to perform validation on CNN model with validation data
  """
  # Set model to evaluation mode
  model.eval()

  # Set initial validation loss and PSNR
  running_loss = 0.0
  running_psnr = 0.0

  # Disable gradient calculation (for inference/validation)
  with torch.no_grad():
    # Loop through each images in Set5
    for batch_idx, data in tqdm(enumerate(val_loader), total=len(val_loader)):
      # Move the LR and HR validation images to device (GPU or CPU)
      lr_image = data[0].to(device)
      hr_image = data[1].to(device)

      # Input LR image into model
      outputs = model(lr_image)
      # Calculate loss for current batch
      loss = loss_function(outputs, hr_image)

      # Add the total loss (to get total loss for current epoch)
      running_loss += loss.item()

      # Calculate PSNR for current batch
      batch_psnr = PSNR(hr_image, outputs)
      # Add the total PSNR (to get total PSNR for current epoch)
      running_psnr += batch_psnr

  avg_loss = running_loss/len(val_loader.dataset)
  avg_psnr = running_psnr/len(val_loader)

